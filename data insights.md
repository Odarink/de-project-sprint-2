1. shipping_country_rates - справочник стоимости доставки в страны.
Для создания таблицы необходимо понять какого типа данных будут столбцы заключенные в ней.
  ID SERIAL - так как ранее такого столбца не сущетсвовало, а он должен являться PK для всей таблицы его необходимо сделать автоинкрементным,
  shipping_country text - такой же тип данных как и в источнике данных (таблицы shipping),
  shipping_country_base_rate NUMERIC(14,3)- такой же тип данных как и в источнике данных (таблицы shipping).
Ну и ID необходимо сделать Primary key.
Практическая часть заключается в:
Удаление таблицы если она существует.
Создание с заданными типами и ограничениями заложенным в задании.
Добавление данных из источника: так как это справочник то мы берем 2 поля из источника оставляя уникальную связку с помощью distinct/group by.
<p>
2. shipping_agreement - справочник тарифов доставки вендора по договору.
Для создания таблицы необходимо понять какого типа данных будут столбцы заключенные в ней. Вся данные таблицы содержатся в столбце 
vendor_agreement_description из источника данных shipping. Пример записи — 12:vsp-34:0.02:0.023. Данные разделены ":".
  agreement_id BIGINT - идентификатор договора, который уже существует в данных и поэтому тип данных обозначается BIGINT (из Пр. 12),
  agreement_number text - номер договора в бухгалтерии, который в данных имеет набор цифр и символов, поэтому тип данных можем обозначить text/varchar (из Пр. 'vsp-34'),
  agreement_rate NUMERIC(14,3) -  ставка налога за стоимость доставки товара для вендора, данный параметр имеет нецелочисленное числовое значение, 
что приводит к типу NUMERIC, однако вопрос сколько цифр после запятой. На схожих метрик внутри источника данных по ставкам налога:shipping_country_base_rate NUMERIC(14,3),
agreement_commission NUMERIC(14,3) - комиссия, то есть доля в платеже являющаяся доходом компании от сделки по схожей с agreement_rate логике для размерности доли ставит тип NUMERIC(14,3).
Ну и agreement_id необходимо сделать Primary key.
Практическая часть заключается в:
Удаление таблицы если она существует.
Создание с заданными типами и ограничениями заложенным в задании.
При проверка заливаемых в таблицу данных неточности при восстановлении данных появится в будущем. Так как все  agreement_rate, agreement_commission будучи строковыми значениями
в составе столбца vendor_agreement_description  имеют всего 2 знака после запятой. Проанализировав все уникальные значения в этих двух 
Возможно изменение типа данных столбцов, необходима консультация с аналитками по данному вопросу. Возможное необходимое решение:
agreement_rate NUMERIC(14,3) --> NUMERIC(14,2) 
agreement_commission NUMERIC(14,3) --> NUMERIC(14,2)  
Однако так как у столбца vendor_agreement_description нет ограничения на длинну строки, то в данной операции нет необходимости, а изменение типа данных можно привязать на скриптах отката.
Все данные были добавлены из источника с помощью distinct записей которые были разбиты на столбцы с помощью regexp_split_to_array(vendor_agreement_description, ':+').
<p>
3. shipping_transfer - справочник о типах доставки.
Для создания таблицы необходимо понять какого типа данных будут столбцы заключенные в ней.
  ID SERIAL - так как ранее такого столбца не сущетсвовало, а он должен являться PK для всей таблицы его необходимо сделать автоинкрементным,
  transfer_type text - тип доставки (таблицы shipping) содержится в строке столбца shipping_transfer_description, имеет набор символов и чисел (1p, 3p), поэтому тип данныъ text,
  transfer_model text— модель доставки (таблицы shipping) содержится в строке столбца shipping_transfer_description, имеет набор символов и чисел (car, train, ...), поэтому тип данныъ text,
  shipping_transfer_rate NUMERIC(14,3)- процент стоимости доставки для вендора в зависимости от типа и модели доставки, такой же тип данных как и в источнике данных (таблицы shipping).
Ну и ID необходимо сделать Primary key.
Практическая часть заключается в:
Удаление таблицы если она существует.
Создание с заданными типами и ограничениями заложенным в задании.
Добавление данных из источника: так как это справочник то мы берем 2 поля из источника оставляя уникальную связку с помощью distinct/group by, одно поле расщепляем на transfer_type:transfer_model.
Полученный уникальных набор данных из 3 столбцов.
<p>
4. shipping_info - справочник комиссий по странам, с уникальными доставками.
  shipping_id BIGINT - уникальный идентификатор доставки из источника в соответствии с типом данных,
  vendor_id BIGINT - уникальный идентификатор вендора в соответствии с типом данных источника,
  payment_amount NUMERIC(14,2) - сумма платежа, тип данных в соответствии с источником,
  shipping_plan_datetime timestamp - плановая дата доставки из источника,
  shipping_transfer_id BIGINT - идентификатор из shipping_transfer по типу доставки,
  shipping_agreement_id BIGINT - идентификатор из shipping_agreement по тарифу доставки,
  shipping_country_rate_id BIGINT - идентификатор из shipping_country_rates по стоимости доставки в страны,
  PRIMARY KEY  по shipping_id
Практическая часть заключается в:
Удаление таблицы если она существует.
Создание с заданными типами и ограничениями заложенным в задании (PK по shipping_id, FK по shipping_transfer_id, 
shipping_agreement_id, shipping_country_rate_id)
JOIN идентификаторов идет из источника по следующим столбцам (shipping_transfer - shipping.shipping_transfer_description,
shipping_country_rates - s.shipping_country)
shipping_agreement_id заложен в источнике подстрокой в vendor_agreement_description.
<p>
5. shipping_status - таблица статусов о доставке
  shipping_id BIGINT - уникальный идентификатор доставки из источника в соответствии с типом данных,
  status text - конечный статус заказа (статус заказа с максимальной датой состояния)
  state text - конечное состояние заказа (состояние заказа с максимальной датой)
  shipping_start_fact_datetime timestamp - дата с state = 'booked'
  shipping_end_fact_datetime timestamp - дата с state = 'received'
  PRIMARY KEY  по shipping_id
Практическая часть заключается в:
Удаление существующей таблицы.
Создание public.shipping_status с PK shipping_id.
Создание cte 3 таблиц: 1) таблица с ранжированной по дате статуса состояния и статусы заказов. 
2) таблица заказов с датой статуса 'booked'.
2) таблица заказов с датой статуса 'received'.
Заполнение таблица public.shipping_status где к таблице (1) JOIN (2), JOIN (3) 
с условием того что берется строка с максимальной датой статуса.
<p>
6. shipping_datamart - таблица для аналитики по заказам
  shipping_id BIGINT - уникальный идентификатор доставки из источника в соответствии с типом данных,
  vendor_id BIGINT - уникальный идентификатор вендора в соответствии с типом данных источника,
  transfer_type text - тип доставки,
  full_day_at_shipping  integer - количество полных дней, в течение которых длилась доставка,
  is_delay boolean - статус, показывающий просрочена ли доставка,
  is_shipping_finish boolean -  статус, показывающий, что доставка завершена,
  delay_day_at_shipping  integer - количество дней, на которые была просрочена доставка,
  payment_amount  NUMERIC(14,2) - сумма платежа пользователя,
  vat NUMERIC(14,2) - итоговый налог на доставку,
  profit NUMERIC(14,2) -  итоговый доход компании с доставки,
  PRIMARY KEY (shipping_id)
Практическая часть заключается в:
Select производится из таблицы shipping_status к которой необходимо присоединить shippinf_info заменив все столбцы
индексов на физические значения. Поэтому сначала идет под запрос join-ов к shipping_info и полученный подзапрос уже
соединяется с shipping_status. Все расчетные формулы: 
  is_delay := shipping_end_fact_datetime > shipping_plan_datetime then 1 else 0.
  is_shipping_finish  := status = finished then 1 else 0.
  delay_day_at_shipping  := when shipping_end_fact_datetime > shipping_plan_datetime then (
    shipping_end_fact_datetime − shipping_plan_datetime) else 0.
  vat := payment_amount * (shipping_country_base_rate + agreement_rate + shipping_transfer_rate).
  profit := payment_amount * agreement_commission.


